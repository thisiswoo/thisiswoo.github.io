---
layout: post
title: "[Routine] 7 주차 시작!"
subtitle: "My 7th week Routine"
category: routine
tags: routine
image:
    path: /assets/img/daily/routine/2023/2023-03-05/2023-03-05-myroutine-7th.png
---

> “**2023년 2월 27일 부터 3월 05일 까지의 나의 루틴.**”

<span style="font-size:30px;">\#**목차**</span>
* this unordered seed list will be replaced by the toc
{:toc}

## 2023-02-27
![2023-02-27](/assets/img/daily/routine/2023/2023-03-05/2023-02-27_myroutine.png){:.centered width="100%"}
- 오늘도 어김없이 영한 님의 인강을 들으면서 출근하였다. 
- 스프링의 핵심원리 기초편이라 아는 부분이 많아서 따로 코드를 작성하지 않으려 한다.
- 내가 모르는 부분이 있을때 코드로 작성하려고 한다.

***
### 컬렉션 자료구조(Set)
#### Set Collection
- `List` 컬렉션은 저장 순서를 유지하지만, `Set` 컬렉션은 저장 순서가 유지되지 않는다.
- 또한 객체를 중복해서 저장할 수 없고, 하나의 `null`만 저장할 수 있다.
- `Set` 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문이다.
![Set Collection](/assets/img/daily/routine/2023/2023-03-05/set.png){:.centered width="100%"}

<table>
  <thead>
    <tr>
      <th style="width: 70px;">기능</th>
      <th style="width: 250px;">메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>객체<br>추가</td>
      <td><code style="border-radius: 0.7em;">boolean add(E e)</code></td>
      <td>주어진 객체를 성공적으로 저장하면 <code style="border-radius: 0.7em;">true</code>를 리턴하고 중복 객체면 <code style="border-radius: 0.7em;">false</code>를 리턴</td>
    </tr>
    <tr>
      <td rowspan="4">객체<br>검색</td>
      <td><code style="border-radius: 0.7em;">boolean contains(Object o)</code></td>
      <td>주어진 객체가 저장되어 있는지 여부</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">isEmpty()</code></td>
      <td>컬렉션이 비어있는지 조사</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Iterator&lt;E&gt; iterator()</code></td>
      <td>저장된 객체를 한 번씩 가져오는 반복자 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">int size()</code></td>
      <td>저장된 모든 객체를 삭제</td>
    </tr>
    <tr>
      <td rowspan="4">객체<br>삭제</td>
      <td><code style="border-radius: 0.7em;">void clear()</code></td>
      <td>저장된 모든 객체를 삭제</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">boolean remove(Object o)</code></td>
      <td>주어진 객체를 삭제</td>
    </tr>
  </tbody>
</table>

#### HashSet
- `Set` 컬렉션 중에서 가장 많이 사용되는 것이 `HashSet`이다.
- `HashSet`은 동일한 객체는 <span style="color:#ff8080">**중복 저장하지 않는다**</span>. 여기서 동일한 객체란 동등 객체를 말한다.
- `HashSet`은 다른 객체라도 `hashCode()` 메서드의 리턴값이 같고, `equals()` 메서드가 `true`를 리턴하면 동일한 객체라고 판단하고 중복 저장하지 않는다.
![Set Collection](/assets/img/daily/routine/2023/2023-03-05/hashset.png){:.centered width="100%"}

```java
public class HashSet {
    public static void main(String[] args) {
        Set<E> set = new HashSet<E>();  // E에 지정된 타입의 객체만 저장
        Set<E> set = new HashSet<>();   // E에 지정된 타입의 객체만 저장
        Set set = new HashSet();        // 모든 타입의 객체를 저장
    }
}
```

- `Set` 컬렉션은 인덱스로 객체를 검색해서 가져오는 메서드가 없다. 대신 객체를 한 개씩 반복해서 가져와야 하는데, 여기에는 <span style="color:#ff8080">**두 가지 방법**</span>이 있다.

```java
//file: "for 문을 이용한 방법.java"
import java.util.HashSet;
import java.util.Set;

public class ForSet {
    public static void main(String[] args) {
        Set<E> set = new HashSet<E>();
        for (E e : set) {
            System.out.println("for Set : " + e);
        }
    }
}
```

- `Set` 컬렉션의 `iterator()` 메서드로 반복자(`iterator`)를 얻어 객체를 하나씩 가져오는 것. 타입 파라미터 `E`는 `Set` 컬렉션에 저장되어 있는 객체의 타입이다.

```java
//file: "set.iterator()를 사용하는 방법.java"

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetIterator {
    public static void main(String[] args) {
        Set<E> set = new HashSet<E>();
        Iterator<E> iterator = set.iterator();
    }
}
```

- `iterator`는 `Set` 컬렉션의 객체를 가져오거나 제거하기 위해 다음 메서드를 제공.

<table>
  <thead>
    <tr>
      <th style="width: 70px;">리턴 타입</th>
      <th style="width: 150px;">메서드 명</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code style="border-radius: 0.7em;">boolean</code></td>
      <td><code style="border-radius: 0.7em;">hasNest()</code></td>
      <td>가져올 객체가 있으면 <code style="border-radius: 0.7em;">true</code>를 리턴하고 없으면 <code style="border-radius: 0.7em;">false</code>를 리턴한다.</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">next()</code></td>
      <td>컬렉션에서 하나의 객체를 가져온다</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">void</code></td>
      <td><code style="border-radius: 0.7em;">remove()</code></td>
      <td><code style="border-radius: 0.7em;">next()</code>로 가져온 객체를 <code style="border-radius: 0.7em;">Set</code> 컬렉션에서 제거한다.</td>
    </tr>
  </tbody>
</table>

- 사용방법

```java
import java.util.Iterator;

public class IteratorHasNextExample {
    public static void main(String[] args) {
        while (iterator.hasNext()) {
            E e = iterator.next();
        }
    }
}
```

Continue with [HashSet Commit](https://github.com/thisiswoo/thisisjava/commit/f2f650e158fb9314fd18e680cfa590230cfb8959){:target="_blank"}{:.heading.flip-title}
{:.read-more}

### Map Collection
- `Map` 컬렉션은 키`key`와 값`value`으로 구성된 엔트리`Entry` 개게를 저장한다. 여기서 키와 값은 모두 객체이다. <span style="color:#ff8080">**키는 중복 저장할 수 없지만 값은 중복 저장할 수 있다**</span>.
- 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 <span style="color:#ff8080">**새로운 값으로 대치**</span>된다.
![Map Collection](/assets/img/daily/routine/2023/2023-03-05/map.png){:.centered width="100%"}

<table>
  <thead>
    <tr>
      <th style="width: 70px;">기능</th>
      <th style="width: 320px;">메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>객체<br />추가</td>
      <td><code style="border-radius: 0.7em;">V put(K key, V value)</code></td>
      <td>주어진 키와 값을 추가, 저장이 되면 값을 리턴</td>
    </tr>
    <tr>
      <td rowspan="8">객체<br />검색</td>
      <td><code style="border-radius: 0.7em;">boolean containsKey(Object key)</code></td>
      <td>주어진 키가 있는지 여부</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">boolean containsValue(Object key)</code></td>
      <td>주어진 값가 있는지 여부</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td>
      <td>키와 값의 쌍으로 구성된 모든 <code style="border-radius: 0.7em;">Map.Entry</code> 객체를 <code style="border-radius: 0.7em;">Set</code>에 담아서 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">V get(Object key)</code></td>
      <td>주어진 키의 값을 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">boolean isEmpty()</code></td>
      <td>컬렉션이 비어있는지 여부</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Set&lt;k&gt; keySet()</code></td>
      <td>저장된 키의 총 수를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">int size()</code></td>
      <td>저장된 키의 총 수를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Collection&lt;V&gt; values()</code></td>
      <td>저장된 모든 값 <code style="border-radius: 0.7em;">Collection</code>에 담아서 리턴</td>
    </tr>
    <tr>
      <td rowspan="2">객체<br />삭제</td>
      <td><code style="border-radius: 0.7em;">void clear()</code></td>
      <td>모든 <code style="border-radius: 0.7em;">Map.Entry</code>(키와 값)를 삭제</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">V remove(Object key)</code></td>
      <td>주어진 키와 일치하는 <code style="border-radius: 0.7em;">Map.Entry</code> 삭제, 삭제가 되면 값을 리턴</td>
    </tr>
  </tbody>
</table>

#### HashMap
- `HashMap`은 `key`로 사용할 객체가 `hashCode()` 메서드의 리턴값이 같고 `equalse()` 메서드가 `true`를 리턴할 경우, 동일 키로 보고 <span style="color:#ff8080">**중복 저장을 허용하지 않는다**</span>.
![HashMap](/assets/img/daily/routine/2023/2023-03-05/hashmap.png){:.centered width="100%"}

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<String, Integer>();  // Key는 String 타입만, Value 값은 Integer만 가능
        Map<String, Integer> map = new HashMap<>();
    }
}
```

Continue with [HashMap Commit](https://github.com/thisiswoo/thisisjava/commit/be6ca3d1a7cc750d36a1ca00e0a97e2a8a4b99c4){:target="_blank"}{:.heading.flip-title}
{:.read-more}

#### Hashtable
- `Hashtable`은 `HashMap`과 동일한 내부 구조를 가지고 있다. 차이점은 `Hashtable`은 동기화된(`synchronized`) 메서드로 구성되어 있기 때문에 멀티 스레드가 동시에 `Hashtable`의 메서드들을 실행할 수 없다는 것이다.
- 따라서 멀티 스레드 환경에서도 <span style="color:#ff8080">**안전하게 객체를 추가, 삭제**</span>할 수 있다.

![Hashtable](/assets/img/daily/routine/2023/2023-03-05/hashtable.png){:.centered width="100%"}

```java
import java.util.HashMap;
import java.util.Map;

public class HashtableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        Map<String, Integer> map = new HashMap<>();
        Map map = new HashMap();    // <- 해당 경우는 거의 없다.
    }
}
```

Continue with [Hashtable Commit](https://github.com/thisiswoo/thisisjava/commit/029cc1e5557cb70e260fa0b2b73394b4d61c287f){:target="_blank"}{:.heading.flip-title}
{:.read-more}

***

## 2023-02-28
![2023-02-28](/assets/img/daily/routine/2023/2023-03-05/2023-02-28_myroutine.png){:.centered width="100%"}
- 늦잠을 자버렸다...😅
- 어김없이 영한 님의 인강과 함께 출근을 하였다.
- 오늘 `HashSet` 다시 복습을 하는데 `for` 문과 `iterator`에서의 [차이점](https://github.com/thisiswoo/thisisjava/commit/f2f650e158fb9314fd18e680cfa590230cfb8959){:target="_blank"}을 새로 알게 되었다.
- **간략하게 말하자면 `for` 문은 몇 번 반목할지 이미 알고 있는 상태. 즉, 반복문 실행 중 반복할 횟수의 대상을 제거하면 `Exception`이 발생하게 된다. 이때 `for` 문이 아닌 `iterator`을 사용해야 한다**.

***

```java
// file: "IteratorRemoveErrorExample.java"
public class IteratorRemoveErrorExample {
    public static void main(String[] args) {
        Set<String> whileSet = new HashSet<String>();
        whileSet.add("Java");
        whileSet.add("Spring");
        whileSet.add("JDBC");
        whileSet.add("JPA");
        
        // 에러 예제 for 문
        for (String element : whileSet) {
            System.out.println("객체를 하나씩 가져와서 처리 element : " + element);
            // 에러 예제
            if (element.equals("Java")) {
                whileSet.remove(element);
                // exception 발생
                // Exception in thread "main" java.util.ConcurrentModificationException
                // at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1597)
                // at java.base/java.util.HashMap$KeyIterator.next(HashMap.java:1620)
                // at ch15.collection_framwork.HashSetExample.main(HashSetExample.java:73)
            }
        }
    }
}
```

- 위 문제 발생을 아래와 같이 해결 할 수 있다.

```java
// file: "IteratorRemoveTroubleshootingExample.java"
public class IteratorRemoveTroubleshootingExample {
    public static void main(String[] args) {
        Set<String> whileSet = new HashSet<String>();
        whileSet.add("Java");
        whileSet.add("Spring");
        whileSet.add("JDBC");
        whileSet.add("JPA");
        
        // 문제 해결 예제
        Iterator<String> iterator = whileSet.iterator();
        while (iterator.hasNext()) {
            String element = iterator.next();
            System.out.println("while() element : " + element);
            if (element.equals("Spring")) {
                iterator.remove();
            }
        }
    }
}
```

### 컬렉션 자료구조(Set)
#### Map Collection
##### Properties
- `Properties`는 `Hashtable`의 자식 클래스이기 때문에 `Hashtable`의 특징을 그대로 가지고 있다.
- `Properties`키와 값을 `String` 타입으로 제한한 컬렉션이다. `Properties`는 주로 확장자가 `.properties`인 프로퍼티 파일을 읽을 때 사용한다.
- 프로퍼티 파일은 다음과  같이 키와 값이 `=` 기호로 연결되어 있는 텍스트 파일이다.
- 일반 텍스트 파일과 다르게 `ISO 8859-1` 문자셋으로 저장되며, 한글이리 경우에는 `\u+`유니코드로 표현되어 저장된다.

```properties
# file: "database.properties"
driver=oracle.jdbc.OracleDriver
url=jdbc:oracle:thin:@localhost:1521:orcl
username=java
paswsord=java
admin=\uD64D\uAE38\uB3D9
```
```java
import java.util.Properties;

public class PropertiesExample {
    public static void main(String[] args) {
        Properties properties = new Properties();
        properties.load(XXX.class.getResourceAsStream("database.properties"));
    }
}
```
Continue with [Properties Commit](https://github.com/thisiswoo/thisisjava/commit/0df2ebc9cd291be7034ceaa0fab30f4275e974c0){:target="_blank"}{:.heading.flip-title}
{:.read-more}

#### 검색 기능을 강화시킨 컬렉션을
- 컬렉션 프레임워크는 검색 기능을 강화시킨 `TreeSet`과 `TreeMap`을 제공한다. 이름에서 알 수 있듯이 `TreeSet`은 `Set` 컬렉션이고, `TreeMap`은 `Map` 컬렉션이다.

##### TreeSet
- `TreeSet`은 이진 트리`binary tree`를 기반으로 한 `Set` 컬렉션이다. 이진 트리는 여러 개의 노드`node`가 트리 형태로 연결된 구로조, 루트 노드`root node`라고 불리는 하나의 노드에서 시작해 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있다.
![RootNode](/assets/img/daily/routine/2023/2023-03-05/rootnode.png){:.centered width="100%"}
- `TreeSet`에 객체를 저장하면 다음과 같이 <span style="color:#ff8080">**자동으로 정렬**</span>된다. 부모 노드의 객체와 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.
![Node](/assets/img/daily/routine/2023/2023-03-05/node.png){:.centered width="100%"}

```java
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        TreeSet<E> treeSet = new TreeSet<E>();
        TreeSet<E> treeSet = new TreeSet<>();
    }
}
```

<table>
  <thead>
    <tr>
      <th style="width: 180px;">리턴 타입</th>
      <th style="width: 250px;">메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">first()</code></td>
      <td><span style="color:#ff8080">제일 낮은</span> 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">last()</code></td>
      <td><span style="color:#ff8080">제일 높은</span> 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">lower(E e)</code></td>
      <td>주어진 객체보다 <span style="color:#ff8080">바로 아래</span> 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">higher(E e)</code></td>
      <td>주어진 객체보다 <span style="color:#ff8080">바로 위</span> 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">floor(E e)</code></td>
      <td>주어진 객체와 <span style="color:#ff8080">동등한 객체</span>가 있으면 리턴,<br> 만약 <span style="color:#ff8080">없다면</span> 주어진 객체의 <span style="color:#ff8080">바로 아래</span>의 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">ceiling(E e)</code></td>
      <td>주어진 객체와 <span style="color:#ff8080">동등한 객체</span>가 있으면 리턴,<br> 만약 <span style="color:#ff8080">없다면</span> 주어진 객체의 <span style="color:#ff8080">바로 위</span>의 객체를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">pollFirst()</code></td>
      <td><span style="color:#ff8080">제일 낮은 객체</span>를 꺼내오고 <span style="color:#ff8080">컬렉션에서 제거</span>함</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">E</code></td>
      <td><code style="border-radius: 0.7em;">pollLast()</code></td>
      <td><span style="color:#ff8080">제일 높은 객체</span>를 꺼내오고 <span style="color:#ff8080">컬렉션에서 제거</span>함</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Iterator&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">descendingIterator()</code></td>
      <td><span style="color:#ff8080">내림차순</span>으로 정렬된 <span style="color:#ff8080">Iterator</span>를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableSet&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">descendingSet()</code></td>
      <td><span style="color:#ff8080">내림차순</span>으로 정렬된 <span style="color:#ff8080">NavigableSet</span>을 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableSet&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">headSet(</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">E toElement,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean inclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td>주어진 객체보다 <span style="color:#ff8080">낮은</span> 객체들을 <span style="color:#ff8080">NavigableSet</span>으로 리턴,<br>주어진 객체 포함 여부는 <span style="color:#ff8080">두 번째 매개값</span>에 따라 달라짐</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableSet&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">tailSet(</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">E fromElement,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean inclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td>주어진 객체보다 <span style="color:#ff8080">높은</span> 객체들을 <span style="color:#ff8080">NavigableSet</span>으로 리턴,<br>주어진 객체 포함 여부는 <span style="color:#ff8080">두 번째 매개값</span>에 따라 달라짐</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableSet&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">subSet(</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">E fromElement,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean fromInclusive,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">E toElement,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean toInclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td><span style="color:#ff8080">시작</span>과 <span style="color:#ff8080">끝</span>으로 주어진 객체 사이의 객체들을 <span style="color:#ff8080">NavigableSet</span>으로 리턴, 시작과 끝 객체의 포함 여부는 <span style="color:#ff8080">두 번째</span>,<span style="color:#ff8080">네 번째 매개값</span>에 따라 달라짐</td>
    </tr>
  </tbody>
</table>

Continue with [TreeSet Commit](https://github.com/thisiswoo/thisisjava/commit/549e7d761e809997fe8cda2e5961a4422e72a4f0){:target="_blank"}{:.heading.flip-title}
{:.read-more}

##### TreeMap
- `TreeMap`은 이진 트리를 기반으로 한 `Map` 컬렉션이다. `TreeSet`과의 차이점은 키와 값이 저장된 `Entry`를 저장한다는 점이다.
- `TreeMap`에 엔트리를 저장하면 키를 기준으로 자동 정렬되는데, 부모 키 값과 비교해서 낮은 것은 왼쪽, 높은 것은 오른쪽 자식 노드에 `Entry` 객체를 저장한다.
![node](/assets/img/daily/routine/2023/2023-03-05/node.png){:.centered width="100%"}

```java
public class TreeMap {
    public static void main(String[] args) {
        TreeMap<K, V> treeMap = new TreeMap<K, V>();
        TreeMap<K, V> treeMap = new TreeMap<>();
    }
}
```

<table>
  <thead>
    <tr>
      <th style="width: 200px;">리턴 타입</th>
      <th style="width: 250px;">메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">firstEntry()</code></td>
      <td><span style="color:#ff8080">제일 낮은</span> Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">lastEntry()</code></td>
      <td><span style="color:#ff8080">제일 높은</span> Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">lowerEntry(K key)</code></td>
      <td>주어진 키보다 <span style="color:#ff8080">바로 아래</span> Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">higherEntry(K key)</code></td>
      <td>주어진 키보다 <span style="color:#ff8080">바로 위</span> Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">floorEntry(K key)</code></td>
      <td>주어진 키와 <span style="color:#ff8080">동등한 키</span>가 있으면 해당 Map.Entry를 리턴,<br><span style="color:#ff8080">없다면</span> 주어진 키 <span style="color:#ff8080">바로 아래</span>의 Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">ceilingEntry(K key)</code></td>
      <td>주어진 키와 <span style="color:#ff8080">동등한 객체</span>가 있으면 해당 Map.Entry를 리턴,<br><span style="color:#ff8080">없다면</span> 주어진 키의 <span style="color:#ff8080">바로 위</span>의 Map.Entry를 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">pollFirst()</code></td>
      <td><span style="color:#ff8080">제일 낮은</span> Map.Entry를 꺼내오고 <span style="color:#ff8080">컬렉션에서 제거</span>함</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">Map.Entry</code></td>
      <td><code style="border-radius: 0.7em;">pollLast()</code></td>
      <td><span style="color:#ff8080">제일 높은</span> Map.Entry를 꺼내오고 <span style="color:#ff8080">컬렉션에서 제거</span>함</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableSet&lt;E&gt;</code></td>
      <td><code style="border-radius: 0.7em;">descendingKeySet()</code></td>
      <td><span style="color:#ff8080">내림차순</span>으로 정렬된 키의 <span style="color:#ff8080">NavigableSet</span>을 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableMap&lt;K, V&gt;</code></td>
      <td><code style="border-radius: 0.7em;">descendingMap()</code></td>
      <td><span style="color:#ff8080">내림차순</span>으로 정렬된 Map.Entry의 <span style="color:#ff8080">NavigableMap</span>을 리턴</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableMap&lt;K, V&gt;</code></td>
      <td><code style="border-radius: 0.7em;">headMap</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">K toKey,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean inclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td>주어진 키보다 <span style="color:#ff8080">낮은</span> Map.Entry들을 <span style="color:#ff8080">NavigableMap</span>으로 리턴,<br>주어진 키의 Map.Entry 포함 여부는 <span style="color:#ff8080">두 번째 매개값</span>에 따라 달라짐</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableMap&lt;K, V&gt;</code></td>
      <td><code style="border-radius: 0.7em;">tailMap(</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">K fromKey,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean inclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td>주어진 객체보다 <span style="color:#ff8080">높은</span> Map.Entry들을 <span style="color:#ff8080">NavigableSet</span>으로 리턴,<br>주어진 객체 포함 여부는 <span style="color:#ff8080">두 번째 매개값</span>에 따라 달라짐</td>
    </tr>
    <tr>
      <td><code style="border-radius: 0.7em;">NavigableMap&lt;K, V&gt;</code></td>
      <td><code style="border-radius: 0.7em;">subMap(</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">K fromKey,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean fromInclusive,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">K toKey,</code><br>&nbsp;&nbsp;&nbsp;<code style="border-radius: 0.7em;">boolean toInclusive</code><br><code style="border-radius: 0.7em;">)</code></td>
      <td><span style="color:#ff8080">시작</span>과 <span style="color:#ff8080">끝</span>으로 주어진 키 사이의 Map.Entry들을 <span style="color:#ff8080">NavigableMap</span>컬렉션으로 반환, 시작과 끝 키의 Map.Entry 포함 여부는 <span style="color:#ff8080">두 번째</span>,<span style="color:#ff8080">네 번째 매개값</span>에 따라 달라짐</td>
    </tr>
  </tbody>
</table>

Continue with [TreeMap Commit](https://github.com/thisiswoo/thisisjava/commit/9ff5b00a271138ddb07316523a09ed369e7de975){:target="_blank"}{:.heading.flip-title}
{:.read-more}

***

## 2023-03-01
- 9시 30분까지 늦잠을 잤다...😁

***

### 컬렉션 자료구조(Set)
#### 검색 기능을 강화시킨 컬렉션
##### Comparable 과 Comparator
- `TreeSet`에 저장되는 객체와 `TreeMap`에 저장되는 키 객체는 저장과 동시에 오름차순으로 정렬되는데, 어떤 객체든 정렬될 수 있는 것은 아니고 객체가 `Comparable` 인터페이스를 구현하고 있어야 가능하다.
- `Integer`, `Double`, `String` 타입은 모두 `Comparable`을 구현하고 있기 때문에 상관 없지만, **사용자 저으이 객체를 저장할 때에는 반드시 `Comparable`을 구현하고 있어야 한다**.

| 리턴타입  | 메서드              | 설명                                                                                                                                                                      |
|-------|------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `int` | `compareTo(T o)` | 주어진 객체와 같으면 <span style="color:#ff8080">0</span>을 리턴<br>주어진 객체보다 적으면 <span style="color:#ff8080">음수</span>를 리턴<br>주어진 객체보다 크면 <span style="color:#ff8080">양수</span>를 리턴 |

Continue with [Comparable Commit](https://github.com/thisiswoo/thisisjava/commit/cb5f63e083dd2769bae5c817e4d676b29bdf5e5d){:target="_blank"}{:.heading.flip-title}
{:.read-more}

- 비교 기능이 있는 `Comparable` 구현 객체를 `TreeSet`에 저장하거나 `TreeMap`의 키로 저장하는 것이 원칙이지만, 비교 기능이 없는 `Comparable` 비구현 객체를 저장하고 싶다면 방법은 없진 않다.
- `TreeSet`과 `TreeMap`을 생성할 때 비교자`Comparator`를 다음과 같이 제공하면 된다.

```java
import java.util.Comparator;
import java.util.TreeMap;
import java.util.TreeSet;

public class ComparatorExample {
    public static void main(String[] args) {
        // new ComparatorImpl() ==> 비교자
        TreeSet<E> treeSet = new TreeSet<E>(new ComparatorImpl());
        TreeMap<K, V> treeMap = new TreeMap<K, V>(new ComparatorImpl());
    }
}
```

- 비교자는 `Comparator` 인터페이스를 구현한 객체를 말하는데, `Comparator` 인터페이스에는 `compare()` 메서드가 정의도어 있다.

<table>
  <thead>
    <tr>
      <th style="width: 100px;">리턴 타입</th>
      <th style="width: 230px;">메서드</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code style="border-radius: 0.7em;">int</code></td>
      <td><code style="border-radius: 0.7em;">compareTo(T o1, T 02)</code></td>
      <td><code style="border-radius: 0.7em;"><span style="color:#ff8080">o1</span></code>과 <code style="border-radius: 0.7em;"><span style="color:#ff8080">o2</span></code>가 동등하다면 <span style="color:#ff8080">0</span>을 리턴<br><code style="border-radius: 0.7em;"><span style="color:#ff8080">o1</span></code>이 <code style="border-radius: 0.7em;"><span style="color:#ff8080">o2</span></code>보다 <span style="color:#ff8080">앞</span>에 오게 하려면 <span style="color:#ff8080">음수</span>를 리턴<br><code style="border-radius: 0.7em;"><span style="color:#ff8080">o1</span></code>이 <code style="border-radius: 0.7em;"><span style="color:#ff8080">o2</span></code>보다 <span style="color:#ff8080">뒤</span>에 오게 하려면 <span style="color:#ff8080">양수</span>를 리턴</td>
    </tr>
  </tbody>
</table>

Continue with [Comparator Commit](https://github.com/thisiswoo/thisisjava/commit/18fc8383a87ba83d11e81a2206ef5ffce990becf){:target="_blank"}{:.heading.flip-title}
{:.read-more}

#### LIFO 와 FIFO 컬렉션
- <span style="color:#ff8080">**후입선출(`LIFO,Last In Out`)**</span>은 **나중에** 넣은 객체가 **먼저 빠져**나가고, <span style="color:#ff8080">**선입선출(`FIFO,First IN First Out`)**</span>은 **먼저** 넣은 객체가 **먼저 빠져**나가는 구조를 말한다.
- 컬렉션 프레임워크는 **`LIFO`** 자료구조를 제공하는 **스택`Stack`** 클래스와 **FIFO** 자료구조를 제공하는 **큐`Queue`** 인터페이스를 제공하고 있다.
![node](/assets/img/daily/routine/2023/2023-03-05/lifo_fifo.png){:.centered width="100%"}

- 스택을 응용한 대표적인 예가 **`JVM`** 스택 메모리이다. 
- 스택 메모리에 저장된 변수는 나중에 저장된 것부터 제거된다.
- 큐를 응용한 대표적인 예가 스레드 풀(ExecutorService)의 작업 큐이다.

##### Stack
- `Stack` 클래스는 **`LIFO`** 자료구조를 구현한 클래스이다.

```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<E> stack = new Stack<E>();
        Stack<E> stack = new Stack<>();
    }
}
```

| 리턴 타입 | 메서드            | 설명                     |
|-------|----------------|------------------------|
| `E`   | `push(E item)` | 주어진 객체를 스택에 넣는다.       |
| `E`   | `pop()`        | 스택의 맨 위 객체를 빼낸다.       |

Continue with [Stack Commit](https://github.com/thisiswoo/thisisjava/commit/07a0b4934b5ed8fbfc7ee29c5302a220324abad1){:target="_blank"}{:.heading.flip-title}
{:.read-more}

##### Queue
- `Queue` 인터페이스는 **`FIFO`** 자료구조에서 사용되는 메서드를 정의하고 있다.

| 리턴 타입      | 메서드          | 설명                  |
|------------|--------------|---------------------|
| `boolean`  | `offer(E e)` | 주어진 객체를 큐에 넣는다.     |
| `E`        | `poll()`     | 큐에서 객체를 빼낸다.        |

```java
import java.util.LinkedList;
import java.util.Queue;

public class StackExample {
    public static void main(String[] args) {
        Queue<E> queue = new LinkedList<E>();
        Queue<E> queue = new LinkedList<>();
    }
}
```

Continue with [Queue Commit](https://github.com/thisiswoo/thisisjava/commit/f74377cb3f80af9fec5d7f09f3b5a24e1c3705b9){:target="_blank"}{:.heading.flip-title}
{:.read-more}

#### 동기화된 컬렉션
- 컬렉션 프레임워크의 대부분의 클래스들은 <span style="color:#ff8080">**싱글 스레드**</span> 환경에서 사용할 수 있도록 설계되었다.
- 그렇기 때문에 여러 스레드가 동시에 컬렉션에 접근한다면 의도하지 않게 요소가 변경될 수 있는 <span style="color:#ff8080">**불안전한 상태**</span>가 된다.
- `Vector`와 `Hashtable`은 동기화된(`synchronized`) 메서드로 구성되어 있기 때문에 멀티 스레드 환경에서 안전하게 요소를 처리할 수 있지만, `ArrayList`, `HashSet`, `HashMap`은 동기화된 메서드로 구성되어 있지 않아 멀티 스레드 환경에서 안전하지 않다.
- 이 경우 멀티 스레드 환경에서 사용하고 싶을 때가 있을 것이다. 이런 경우를 대비해서 컬렉션 프레임워크는 비동기화된 메서드를 동기화된 메서드로 래핑하는 `Collection`의 `synchronizedXXX()` 메서드를 제공한다.

| 리턴 타입       | 메서드(매개변수)                        | 설명                      |
|-------------|----------------------------------|-------------------------|
| `List<T>`   | `synchronizedList(List<T> list)` | `List`를 통기화된 `List`로 리턴 |
| `Map<K, V>` | `synchronizedMap(Map<K, V> m)`   | `Map`를 통기화된 `Map`로 리턴   |
| `Set<T>`    | `synchronizedSet(Set<T> s)`      | `Set`를 통기화된 `Set`로 리턴   |

- `ArrayList`를 `Collections.synchronizedList()` 메서드를 사용해서 동기화된 `List`로 변환된다.
![synchronized_collection_1](/assets/img/daily/routine/2023/2023-03-05/synchronized_collection_1.png){:.centered width="100%"}
- `HashSet`를 `Collections.synchronizedSet()` 메서드를 사용해서 동기화된 `Set`로 변환된다.
  ![synchronized_collection_2](/assets/img/daily/routine/2023/2023-03-05/synchronized_collection_2.png){:.centered width="100%"}
- `HashSet`를 `Collections.synchronizedMap()` 메서드를 사용해서 동기화된 `Map`로 변환된다.
  ![synchronized_collection_3](/assets/img/daily/routine/2023/2023-03-05/synchronized_collection_3.png){:.centered width="100%"}

```java
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class SynchronizedMapExample {
    public static void main(String[] args) {
        Map<Integer, String> map = Collections.synchronizedMap(new HashMap<>());    // 출력 : 일정한 값
        Map<Integer, String> map = new HashMap<>();    // 출력 : 일정하지 않은 값
    }
}
```

- `HashMap`은 두 스레드가 동시에 `put()` 메서드를 호출할 수 있기 때문에 경합이 발생하고 결국 하나만 저장되기 때문이다.
- 하지만 동기화된 `Map`은 한 번에 하나의 스레드만 `put()` 메서드를 호출할 수 있기 때문에 경합이 발생하지 않는다.

Continue with [SynchronizedMap  Commit](https://github.com/thisiswoo/thisisjava/commit/d8eee2bab6bc0e9cac6ecd800c27ea8b93376c9b){:target="_blank"}{:.heading.flip-title}
{:.read-more}

#### 수정할 수 없는 컬렉션
- 수정할 수 없는(`unmodifiable`) 컬렉션이란 요소를 추가, 삭제할 수 없는 컬렉션을 말한다.
- 첫 번째 방법으로는 `List`, `Set`, `Map` 인터페이스의 정적 메서드인 `of()`로 생성할 수 있다.
```shell
List<E> immutableList = List.of(E... elements);
Set<E> immutableSet = Set.of(E... elements);
Map<K, V> immutableMap = Map.of(K k1, V v1, K k2, V v2, ...);
```

- 두 번째 방법은 `List`, `Set`, `Map` 인터페이스의 정적 메서드인 `copyOf()`을 이용해 기존 컬렉션을 복사하여 수정할 수 없는 컬렉현을 만든는 것이다.
```shell
List<E> immutableList = List.copyOf(Collection<E> coll);
Set<E> immutableSet = Set.copyOf(Collection<E> coll);
Map<K, V> immutableMap = Map.copyOf(Map<K, V> map);
```

- 세 번째 방법은 배열로부터 수정할 수 없는 `List` 컬렉션을 만들 수 있다.
```shell
String[] arr = {"A", "B", "C"};
List<String> immutableList = Arrays.asList(arr);
```

Continue with [Unmodifiable  Commit](https://github.com/thisiswoo/thisisjava/commit/e28c424ebe51d25033558b2acd64c3294b6c7001){:target="_blank"}{:.heading.flip-title}
{:.read-more}

***

## 2023-03-02
## 2023-03-03
## 2023-03-04
## 2023-03-05

## Reference
- [이것이 자바다](https://www.youtube.com/watch?v=PqZ1imcTBpI&list=PLVsNizTWUw7EmX1Y-7tB2EmsK6nu6Q10q){:target="_blank"}

Back to [[Routine] 6 주차 시작!](../02-february/2023-02-26-week-6th.md){:.heading.flip-title}
{:.read-more}

[//]: # (Continue with [[Routine] 7 주차 시작!]&#40;../03-march/2023-02-25-week-7th.md&#41;{:.heading.flip-title})

[//]: # ({:.read-more})

