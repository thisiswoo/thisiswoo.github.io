---
layout: post
title: "[SQL] SQLD 핵심 요약"
subtitle: "SQLD Core Summary"
category: development
tags: database SQL SQLD
image:
  path: /assets/img/development/database/2023-01-05/sql_d_logo.png
---

<span style="font-size:30px;">\#**목차**</span>
* this unordered seed list will be replaced by the toc
{:toc}

# 데이터 모델링의 이해

## 데이터 모델링의 정의
- **정보시스템 구축을 위한 데이터 관점의 업무 분석기법**
- **현실세계 데이터에 대해 약속된 표기법에 의해 표현하는 과정**
- **데이터베이스 구축하기 위한 분석, 설계 과정**

### 모델링의 특징
- **추상화** : 현실세계를 인정한 형식에 맞추어 표현
- **단순화** : 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현 
- **명확화** : 누구나 이해하기 쉽게 대상에 대한 애매모호함 제거

### 모델링의 세 가지 관점
- **데이터 관점** : 업무가 어떤 데이터와 관련이 있는지, 데이터간 관계가 무엇인지 (What, Data)
- **프로세스 관점** : 업무가 실제로 하고있는 일이 무엇인, 무엇을 해야하는지 (How, Process)
- **상관 관점** : 업무 처리하는 방법에 따라 데이터가 어떻게 영향을 받고 있는지 (Interaction)

### 데이터 모델링의 기능
- **명세화**, **구조화**, **문서화**, **다양한 관점**, **상세수준 표현**

### 데이터 모델링의 중요성 및 유의점
- **중복** : 같은 시간 같은 데이터 제공
- **비유연성** : 사소한 업무변화에 데이터 모델이 수시로 변경되면 안됨
- **비일관성** : 신용 상태에 대한 갱신 없이 고객의 납부이력 정보 갱신 안됨(연계성이 떯어짐)

### 데이터 모델링의 3단계 진행
- **(추상적)개념적 -> 논리적 -> 물리적(구체적)**<br>
  - **개념적 데이터 모델링(in계획분석단계) : 추상화, 업무중심적, 포괄적, 전사적, EA수립시 사용**
  - **논리적 데이터 모델링(in분석단계) : KEY, 속성, 관계 표현, 재사용성 높음(정규화)**
  - **물리적 데이터 모델링(in설계단계) : 실제 데이터베이스를 이식할 수 있도록 성능, 저장 등 무릴적 성격 고려**

### 데이터 독립성 요소
- **왜부 스키마** : 개개 사용자가 보는 개인적 DB 스키마
- **개념 스키마** : 모든 사용자 관점을 통합한 전체 DB 
- **내부 스키마** : 물리적 장치에서 데이터가 실제적 저장 

### 데이터 독립성
- **논리적 독립성** : 개념 스키마가 변경되어도 외부 스키마에 영향X
- **물리적 독립성** : 내부 스키마가 변경되어도 외부/개념 스키마는 영향X

### Mapping(사상)
- **상호 독립적인 개념을 연결시켜주는 다리**

### 데이터 모델링의 3요소
- **어떤 것(Things)**, **성격(Attributes)**, **관계(Relationships)**
- **데이터 모델링은 프로젝트에 참여한 모두가 알아야 한다**
- **엔티티: 집합 / 인스턴스 : 단수**

### 데이터 모델 표기법
- 1976년 피터첸이 Entity Relationships Model 개발

### ERD 작업 순서
1. 엔티티를 그림
2. 엔티티를 적절하게 배치
3. 엔티티간 관계를 설정
4. 관계명을 기술
5. 관계의 참여도를 기술
6. 관계의 필수여부를 기술

### 좋은 데이터 모델의 요소
1. **완전성** : 업무에 필요한 모든 데이터가 모델에 정의
2. **중복배제** : 하나의 DB내에 동일한 사실은 한번만
3. **업무규칙** : 많은 규칙을 사용자가 공유하도록 제공
4. **데이터 재사용** : 데이터가 독립적으로 설계돼야 함
5. **의사소통** : 업무규칙은 엔티티, 서브타입, 속성, 관계 등의 형태로 퇴대한 자세히 표현
6. **통합성** : 동일한 데이터는 한 번만 정의, 참조활용

## 엔티티란?
- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것, 보이지 않는 개념 포함

### 엔티티의 특징
1. 반드시 해당 업무에서 필요하고 관리하고자 함
2. 유일한 식별자에 의해 식별 가능
3. 두 개 이상의 인스턴스의 집합
4. 업무 프로세스에 의해 이용되어야 함
5. 반드시 속성이 있어야 함(예외적으로 관계엔티티 경우는 주식별자 속성만 가지고 있어도 엔티티로 인정)
6. 다른 엔티티와 최소 1개 이상의 관계가 있어야 함(관계를 생략하여 표현해야하는 경우는 통계성 엔티티, 코드성 엔티티, 시스템 처리시 내부 필요에 의한 엔티티 도출과 같은 경우)

### 엔티티의 분류

#### 유무형에 따른 분류
- **유형** : 물리적 형태, 안정적, 지속적 ex)사원, 물품, 강사
- **개념** : 개념적 정보, 물리적 형태X ex)조직, 보험상품
- **사건** : 업무수행시 발생, 통계자료 이용 ex)주문, 청구, 미납

#### 발생시접에 따른 분류
- **기본** : 그 업무에 원래 존재하는 정보, 타 엔티티의 부모 역할, 자신의 고유한 주식별자 가짐 ex)사원, 부서
- **중심** : 기본 엔티티로부터 발생, 다른 엔티티와의 관계로 많은 행위 엔티티 생성 ex)계약, 사고, 주문
- **행위** : 2개 이상의 부모엔티티로부터 발생, 자주 바뀌거나 양이 증가 ex)주문목록, 사원변경이력

#### 엔티티의 명명
- **현업업무에서 사용하는 용어 사용, 약어 사용금지, 단수명사 사용, 고유한 이름 사용, 생성의미대로 부여**

## 속성
- **업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 분리되지 않는 최소의 데이터 단위**
- 한 개의 엔티티는 2개 이상의 인스턴스 집합
- 한 개의 엔티티는 2개 이상의 속성을 가짐
- 한 개의 속성은 1개의 속성값을 가짐

### 속성의 분류
- **기본** : 업무로부터 추출한 모든 일반적인 속성
- **설계** : 업무를 규칙화하기 위해 새로 만들거나 변형, 정의하는 속성 ex)일련번호
- **파생** : 다른 속성에 영향을 받아 발생하는 속성, 빠른 성능을 낼 수 있도록 원래 속성의 값을 계산 ex)합 

### 도메인
- 각 속성이 가질 수 잇는 값의 범위 ex)5글

### 속성의 명명
1. 해당업무에서 사용하는 이름 부여
2. 서술식 속성명은 사용 금지
3. 약어 사용 금지
4. 전체 데이터모델에서 유일성 확보

## 관계
- ** 엔티티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태
  - 존재에 의한 관계 ex)소속된다
  - 행위에 의한 관계 ex)주문한다

### 패어링
- **엔티티 안에 인스턴스가 개별적으로 관계를 가지는 것**

#### UML
- **UML**에는 연관관계와 의존관계가 있는데, 연관(존재적)관계는 항상 이용하는 관계이고 의존관계는 상대방 행위에 의해 발생하는 관계

#### ERD
- **ERD**에서는 존재적 관계와 행위에  의한 관계를 구분하지 않고 표기했지만 **UML**에서는 이를 구분하여 **연관관계는 실선**, **의존관계는 점선**으로 표현

### 관계의 표기법
- **관계명** : 관계의 이름
- **관계차수** : 1:1(One to One), 1:M(One to Many), M:N(Many to Many(n개))
- **관계선택성(관계선택사양)** : 필수관계, 선택관계

### 관계 체크사항
1. 2개의 엔티티 사이에 관심있는 <u>연관 규칙</u> O/X?
2. 2개의 엔티티 사이에 정보의 <u>조합 발생</u> O/X?
3. 업무기술서, 장표에 <u>관계연결에 대한 규칙</u> 서술 O/X?
4. 업무기술서, 장표에 관계연결을 가능케 하는 <u>동사</u> O/X?

## 식별자
- **엔티티내에서 인스턴스를 구분하는 구분자 식별자는 논리 데이터 모델링 단계에 사용**
- **key는 물리 데이터 모델링 단계에 사용**

### 식별자의 특징 : 유일성, 최소성, 불변성, 존재성
1. 주식별자에 의해 모든 인스턴스들이 유일하게 구분
2. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
3. 지정된 주식별자의 값은 자주 변하지 않아야 함
4. 주식별자가 지정이 되면 반드시 값이 들어와야 함

### 식별자 분류

#### 대표성여부 : 주식별자, 보조식별자
- **주식별자** : 엔티티 내에서 각 어커런스를 구분할 수 있는 구분자, 타 엔티티와 참조관계를 연결할 수 있음
- **보조식별자** : 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결 불가

#### 스스로 생성여부 : 내부식별자, 외부식별자
- **내부식별자** : 스스로 생성되는 식별자
- **외부식별자** : 타 엔티티로부터 받아오는 식별자

#### 속성의 수 : 단일식별자, 복합식별자
- **단일식별자** : 하나의 속성으로 구성
- **복합식별자** : 2개 이상의 속성으로 구성

#### 대체 여부 : 본질식별자, 인조식별자
- **본질식별자** : 업무에 의해 만들어지는 식별자
- **인조식별자** : 인위적으로 만든 식별자

#### 주식별자 도출기준
1. 해당 업무에서 자주 이용되는 속석임
2. 명칭, 내역 등과 같이 이름으로 기술되는 것들은 X
3. 복합으로 주식별자로 구성할 경우 너무 많은 속성 X

### 식별자 관계

#### 주식별자
- 자식의 주식별자로 부모의 주식별자 상속
  - 부모로부터 받은 식별자를 자식엔티티의 주식별자로 이용하는 경우

#### 비식별자
- 부모 속성을 자식의 일반 속성으로 사용
  1. 부모 없는 자식이 생성될 수 있는 경우
  2. 부모와 자식의 생명주기가 다른 경우
  3. 여러개의 엔티티가 하나의 엔티티로 통합되어 표현되었는데 각각의 엔티티가 별도의 관계를 가진 경우
  4. 자식엔티티에 별도의 주식별자를 생성하는 것이 더 유리한 경우
  5. SQL 문장이 길어져 복잡성 증가되는 것 방지
    - 약한 연결관계 표현, 점선 표기
    - 자식 주식별자구성을 독립적으로 구성

# 데이터 모델과 성능

## 성능 데이터 모델링
- DB 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK, 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것
- <u>분석/설계 단계에서</u> 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화 할 수 있는 기회를 가지게 된다.
- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 기하급수적으로 증가하게 된다.

## 성능 데이터 모델링 고려사항 순서
1. 데이터 모델링을 할 때 정규화를 정확하게 수행
2. DB 용량 산정을 수행한다.
3. DB에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행
5. 이력모델의 조정, PK/FK조정, 슈퍼/서브타입 조정
6. 선능관점에서 데이터 모델을 검증한다.

- 기본적으로 데이터는 속성간의 함수종속성에 근거하여 정규화되어야 한다.
- 겅규화는 선택이 아니라 필수사항

## 함수적 종속성
- 데이터들이 어떤 기준 값에 의해 종속되는 현상

## 정규화
- 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것
- 칼럼에 의한 반복, 중복적인 속성 값을 갖는 형태는 1차 정규화의 대상

## 반정규화
- 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델리으이 기법
- 일반적으로 정구화시 입력/수정/삭제 성능이 향상되며 반정규화시 조인 성능이 향상된다.

## 반정규화 절차
1. 반정규화 대상조사(범위처리 빈도 수, 범위, 통계성)
2. 다른 방법유도 검토(뷰, 클러스터링, 인덱스 조정)
3. 반정규화 적용(테이블, 속성, 관계 반정규화)

## 반정규화 대상조사
1. 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
2. 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
3. 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계 테이블을 생성한다
4. 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 SORTING, ORDER BY는 반정규화 대상X

## 다른방법유도 검토
1. 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용한다
2. 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정함
3. 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다(파티셔닝 기법)
4. 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

## 반정규화의 기법(테이블, 칼럼, 관계)

### 테이블 반정규화
- **테이블 병합(1:1관계, 1:M관계, 슈퍼/서브타입)**
1. 1:1관계를 통합하여 선능향상
2. 1:M관계를 통합하여 선능향상
3. 슈퍼/서브 관계를 통합하여 성능향상

- **테이블 분할(수직분할, 수평분할)**
1. **수직분할** : Column단위 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상
2. **수평분할** : Row단위 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 Row단위로 테이블을 쪼갬

- **테이블 추가(중복, 통계, 이력, 부분 테이블 추가)**
1. **중복** : 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능 향상
2. **통계** : SUM, AVG, 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상
3. **이력** : 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
4. **부분** : 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아 놓은 별도의 반정규화된 테이블을 생성

### 칼럼 반정규화(중복, 파생, 이력, PK, 오작동)
1. **중복** : 조인에 의해 ㅓ리할 때 성능저하를 예방하기 위해 중복된 칼럼을 위치 시킴
2. **파생** : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계싼하여 칼럼에 보관
3. **이력테이블** : 대량의 이력데이터를 처리할 때 불특정날 조회나 최근 값을 조회할 때 나타날 수 있는성능저하를 예방하기 위해 이력테이블에 가능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함
4. **PK에 의한 칼럼 추가** : 이미 PK안에 데이터가 존재하지만 선능향상을 위해 일반속성으로 포함하는 방법
5. **응용시스템 오작동을 위한 칼럼 추가** : 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복귀하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법


